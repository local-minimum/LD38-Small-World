#region License

// https://github.com/TheBerkin/Rant
// 
// Copyright (c) 2017 Nicholas Fleck
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy,
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so, subject to the
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#endregion

using System.Collections;
using System.Collections.Generic;
using System.Linq;

using Rant.Core.Output;

namespace Rant
{
    /// <summary>
    /// Represents a collection of strings generated by a pattern.
    /// </summary>
    public sealed class RantOutput : IEnumerable<RantOutputEntry>
    {
        private readonly Dictionary<string, RantOutputEntry> _outputs;

        internal RantOutput(long seed, long startingGen, IEnumerable<OutputChain> chains)
        {
            _outputs = chains.ToDictionary(chain => chain.Name,
                chain => new RantOutputEntry(chain.Name, chain.ToString(), chain.Visibility));
            Seed = seed;
            BaseGeneration = startingGen;
        }

        /// <summary>
        /// Gets the output of the channel with the specified name.
        /// </summary>
        /// <param name="channel">The name of the channel.</param>
        /// <returns></returns>
        public string this[string channel]
        {
            get
            {
                RantOutputEntry value;
                return _outputs.TryGetValue(channel, out value) ? value.Value : string.Empty;
            }
        }

        /// <summary>
        /// Gets an array containing the values of the specified channels, in the order they appear.
        /// </summary>
        /// <param name="channels">The names of the channels whose values are to be retrieved.</param>
        /// <returns></returns>
        public string[] this[params string[] channels]
        {
            get
            {
                if (channels == null || channels.Length == 0) return new string[0];
                var output = new string[channels.Length];
                for (int i = 0; i < channels.Length; i++)
                {
                    if (channels[i] == null)
                    {
                        output[i] = string.Empty;
                        continue;
                    }
                    RantOutputEntry value;
                    if (_outputs.TryGetValue(channels[i], out value))
                        channels[i] = value.Value;
                    else
                        channels[i] = string.Empty;
                }
                return channels;
            }
        }

        /// <summary>
        /// The seed used to generate the output.
        /// </summary>
        public long Seed { get; }

        /// <summary>
        /// The generation at which the RNG was initially set before the pattern was run.
        /// </summary>
        public long BaseGeneration { get; }

        /// <summary>
        /// The main output string.
        /// </summary>
		public string Main { get { return  _outputs ["main"].Value; }}
        /// <summary>
        /// Returns an enumerator that iterates through the outputs in the collection.
        /// </summary>
        /// <returns></returns>
		public IEnumerator<RantOutputEntry> GetEnumerator() { return  _outputs.Values.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator() { return _outputs.Values.GetEnumerator();
		}
        /// <summary>
        /// Returns the output from the "main" channel.
        /// </summary>
        /// <returns></returns>
		public override string ToString() {
			return Main;
		}
        /// <summary>
        /// Returns the output from the "main" channel.
        /// </summary>
        /// <returns></returns>
		public static implicit operator string (RantOutput output)
		{
		return	output.Main;
		}

	}
}